{"mappings":"AGeA;IACE,IAAI,EAAE,MAAM,CAAC;IACb,KAAK,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,IAAI,CAAC;CACnC;ACbD,0BAA0B,CAAC,IAAI;IAAE,OAAO,EAAE,IAAI,CAAC;IAAC,OAAO,CAAC,EAAE,CAAC,CAAA;CAAE,CAAC;AAE9D,0BAA0B;IAAE,OAAO,EAAE,KAAK,CAAC;IAAC,KAAK,EAAE,MAAM,CAAA;CAAE,CAAC;AAE5D,mBAAmB,CAAC,IAAI,cAAc,CAAC,CAAC,GAAG,WAAW,CAAC;AAEvD;gBACqB,IAAI,EAAE,WAAW,GAAG,IAAI;IAWpC,OAAO,CAAC,EACb,KAAK,EACL,QAAQ,EACR,IAAI,EACJ,KAAK,GACN,EAAE,cAAc,GAAG,OAAO,IAAI,CAAC;IAwEzB,QAAQ,CAAC,KAAK,EAAE,cAAc,EAAE,GAAG,OAAO,IAAI,CAAC;IAgD/C,UAAU,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC,EAAE,MAAM,IAAI,GAAG,IAAI;CA0B7D;AAED,QAAQ,MAAM,CAAC;IACb,UAAU,MAAM;QACd,gBAAgB,EAAE,QAAQ,CAAC,gBAAgB,CAAC,CAAC;KAC9C;CACF","sources":["src/src/model.ts","src/src/view/makeMoveable.ts","src/src/view/view.ts","src/src/controller.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,null,null,null,"import Model from './model';\nimport Controller, {\n  InternalLineInitParams,\n  LineInitParams,\n} from './controller';\nimport View from './view/view';\n\nexport type SuccessResult<T> = { success: true; payload?: T };\n\nexport type ErrorResult = { success: false; error: string };\n\nexport type Result<T> = SuccessResult<T> | ErrorResult;\n\nexport default class PercentageSlider {\n  public constructor(node: HTMLElement | null) {\n    if (!node) {\n      console.warn('Node is empty!');\n      return;\n    }\n\n    this.model = new Model();\n    this.view = new View(node);\n    this.controller = new Controller(this.model, this.view);\n  }\n\n  public addLine({\n    value,\n    onChange,\n    name,\n    color,\n  }: LineInitParams): Result<void> {\n    if (!this.model.isValidValue(value)) {\n      return {\n        success: false,\n        error: \"Total can't be greater than \" + Model.TOTAL + '.',\n      };\n    }\n\n    const hasNameAlreadyTaken = this.model.lines[name];\n\n    if (!name || name.trim().length === 0) {\n      return { success: false, error: `The name can't be empty.` };\n    }\n\n    if (hasNameAlreadyTaken) {\n      return { success: false, error: `The name '${name}' is already in use.` };\n    }\n\n    if (this.model.hasNoLines()) {\n      try {\n        const validValue = parseInt(`${value}`, 10) || Model.TOTAL;\n        const lineParams = {\n          name: name,\n          value: validValue,\n          onChange: this.mkOnChange(onChange),\n          color: color || View.getRandomColor(),\n        };\n\n        const lineData = this.controller.createSingleLine(lineParams);\n\n        this.view.appendElement(lineData.line);\n\n        if (value && !isNaN(value)) {\n          this._wasChanged = true;\n        }\n        return { success: true };\n      } catch (e) {\n        return { success: false, error: e };\n      }\n    }\n\n    const lineParams = {\n      name,\n      value: value || 0,\n      onChange: this.mkOnChange(onChange),\n      color: color || View.getRandomColor(),\n    };\n\n    const lwh = this.controller.createLineWithHandle(lineParams);\n\n    if (value && !isNaN(value)) {\n      this._wasChanged = true;\n      this.controller.addLineWithHandleToSlider(value, lwh);\n      return { success: true };\n    }\n\n    if (this._wasChanged) {\n      const noSpaceLeft = this.model.getSumOfLines() === Model.TOTAL;\n      if (noSpaceLeft) {\n        this.controller.addLineWithHandleToSliderBySplitLastLine(lwh);\n      } else {\n        this.controller.addLineWithHandleToSliderGreedy(lwh);\n      }\n\n      return { success: true };\n    }\n\n    this.controller.addLineWithHandleToSliderAuto(lwh);\n\n    return { success: true };\n  }\n\n  public addLines(lines: LineInitParams[]): Result<void> {\n    const someLinesAlreadyAdded = Object.keys(this.model.lines).length !== 0;\n\n    if (someLinesAlreadyAdded) {\n      return {\n        success: false,\n        error:\n          'Lines can not be added to already initialized slider. Instead, you can add lines one at a time.',\n      };\n    }\n\n    const linesDataSum = lines.reduce(\n      (acc, curr) => acc + (curr.value || 0),\n      0\n    );\n\n    if (linesDataSum > Model.TOTAL) {\n      return {\n        success: false,\n        error: `Sum of lines can not be great than ${Model.TOTAL}.`,\n      };\n    }\n\n    if (lines.length === 0) {\n      return {\n        success: false,\n        error: 'Cannot initialize strips with an empty array.',\n      };\n    }\n\n    let internalLineInitParams: Array<InternalLineInitParams> = lines.map(\n      (line: LineInitParams) => {\n        return {\n          ...line,\n          color: line.color || View.getRandomColor(),\n          value: line.value || 0,\n          onChange: this.mkOnChange(line.onChange),\n        };\n      }\n    );\n\n    var internalLines = this.controller.createLines(internalLineInitParams);\n\n    this.controller.addLinesToSlider(internalLines);\n\n    return { success: true };\n  }\n\n  public removeLine(name: string, onRemove?: () => void): void {\n    this.controller.removeLine(name, this.mkOnRemove(onRemove));\n  }\n\n  private model: Model;\n  private view: View;\n  private controller: Controller;\n  private _wasChanged = false;\n\n  private mkOnChange(\n    onChange?: (value: number) => void\n  ): (value: number, options: { auto: boolean }) => void {\n    return ((value: number, options: { auto: boolean }) => {\n      var auto = options && options.auto;\n\n      this._wasChanged = auto ? this._wasChanged : true;\n\n      onChange && onChange(value);\n    }).bind(this);\n  }\n\n  private mkOnRemove(onRemove?: () => void): () => void {\n    return function () {\n      onRemove && onRemove();\n    }.bind(this);\n  }\n}\n\ndeclare global {\n  interface Window {\n    PercentageSlider: ThisType<PercentageSlider>;\n  }\n}\n\nwindow.PercentageSlider = PercentageSlider;\n"],"names":[],"version":3,"file":"types.d.ts.map"}